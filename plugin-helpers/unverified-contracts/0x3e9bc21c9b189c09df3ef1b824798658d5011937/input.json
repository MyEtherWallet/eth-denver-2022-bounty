{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "LnProxyERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.6.12;\r\n\r\ninterface IERC20 {\r\n    \r\n    function name() external view returns (string memory);\r\n\r\n    function symbol() external view returns (string memory);\r\n\r\n    function decimals() external view returns (uint8);\r\n\r\n    function totalSupply() external view returns (uint);\r\n\r\n    function balanceOf(address owner) external view returns (uint);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n\r\n    function transfer(address to, uint value) external returns (bool);\r\n\r\n    function approve(address spender, uint value) external returns (bool);\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint value\r\n    ) external returns (bool);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\ncontract LnAdmin {\r\n    address public admin;\r\n    address public candidate;\r\n\r\n    constructor(address _admin) public {\r\n        require(_admin != address(0), \"admin address cannot be 0\");\r\n        admin = _admin;\r\n        emit AdminChanged(address(0), _admin);\r\n    }\r\n\r\n    function setCandidate(address _candidate) external onlyAdmin {\r\n        address old = candidate;\r\n        candidate = _candidate;\r\n        emit candidateChanged( old, candidate);\r\n    }\r\n\r\n    function becomeAdmin( ) external {\r\n        require( msg.sender == candidate, \"Only candidate can become admin\");\r\n        address old = admin;\r\n        admin = candidate;\r\n        emit AdminChanged( old, admin ); \r\n    }\r\n\r\n    modifier onlyAdmin {\r\n        require( (msg.sender == admin), \"Only the contract admin can perform this action\");\r\n        _;\r\n    }\r\n\r\n    event candidateChanged(address oldCandidate, address newCandidate );\r\n    event AdminChanged(address oldAdmin, address newAdmin);\r\n}\r\n\r\ncontract LnProxyBase is LnAdmin {\r\n    LnProxyImpl public target;\r\n\r\n    constructor(address _admin) public LnAdmin(_admin) {}\r\n\r\n    function setTarget(LnProxyImpl _target) external onlyAdmin {\r\n        target = _target;\r\n        emit TargetUpdated(_target);\r\n    }\r\n\r\n    function Log0( bytes calldata callData ) external onlyTarget {\r\n        uint size = callData.length;\r\n        bytes memory _callData = callData;\r\n        assembly {\r\n            log0(add(_callData, 32), size)\r\n        }\r\n    }\r\n\r\n    function Log1( bytes calldata callData, bytes32 topic1 ) external onlyTarget {\r\n        uint size = callData.length;\r\n        bytes memory _callData = callData;\r\n        assembly {\r\n            log1(add(_callData, 32), size, topic1 )\r\n        }\r\n    }\r\n\r\n    function Log2( bytes calldata callData, bytes32 topic1, bytes32 topic2 ) external onlyTarget {\r\n        uint size = callData.length;\r\n        bytes memory _callData = callData;\r\n        assembly {\r\n            log2(add(_callData, 32), size, topic1, topic2 )\r\n        }\r\n    }\r\n\r\n    function Log3( bytes calldata callData, bytes32 topic1, bytes32 topic2, bytes32 topic3 ) external onlyTarget {\r\n        uint size = callData.length;\r\n        bytes memory _callData = callData;\r\n        assembly {\r\n            log3(add(_callData, 32), size, topic1, topic2, topic3 )\r\n        }\r\n    }\r\n\r\n    function Log4( bytes calldata callData, bytes32 topic1, bytes32 topic2, bytes32 topic3, bytes32 topic4 ) external onlyTarget {\r\n        uint size = callData.length;\r\n        bytes memory _callData = callData;\r\n        assembly {\r\n            log4(add(_callData, 32), size, topic1, topic2, topic3, topic4 )\r\n        }\r\n    }\r\n\r\n    //receive: It is executed on a call to the contract with empty calldata. This is the function that is executed on plain Ether transfers (e.g. via .send() or .transfer()).\r\n    //fallback: can only rely on 2300 gas being available,\r\n    receive() external payable {\r\n        target.setMessageSender(msg.sender);\r\n\r\n        assembly {\r\n            let free_ptr := mload(0x40)\r\n            calldatacopy(free_ptr, 0, calldatasize())\r\n\r\n            let result := call(gas(), sload(target_slot), callvalue(), free_ptr, calldatasize(), 0, 0)\r\n            returndatacopy(free_ptr, 0, returndatasize())\r\n\r\n            if iszero(result) {\r\n                revert(free_ptr, returndatasize())\r\n            }\r\n            return(free_ptr, returndatasize())\r\n        }\r\n    }\r\n\r\n    modifier onlyTarget {\r\n        require(LnProxyImpl(msg.sender) == target, \"Must be proxy target\");\r\n        _;\r\n    }\r\n\r\n    event TargetUpdated(LnProxyImpl newTarget);\r\n}\r\n\r\n\r\nabstract contract LnProxyImpl is LnAdmin {\r\n    \r\n    LnProxyBase public proxy;\r\n    LnProxyBase public integrationProxy;\r\n\r\n    address public messageSender;\r\n\r\n    constructor(address payable _proxy) internal {\r\n        \r\n        require(admin != address(0), \"Admin must be set\");\r\n\r\n        proxy = LnProxyBase(_proxy);\r\n        emit ProxyUpdated(_proxy);\r\n    }\r\n\r\n    function setProxy(address payable _proxy) external onlyAdmin {\r\n        proxy = LnProxyBase(_proxy);\r\n        emit ProxyUpdated(_proxy);\r\n    }\r\n\r\n    function setIntegrationProxy(address payable _integrationProxy) external onlyAdmin {\r\n        integrationProxy = LnProxyBase(_integrationProxy);\r\n    }\r\n\r\n    function setMessageSender(address sender) external onlyProxy {\r\n        messageSender = sender;\r\n    }\r\n\r\n    modifier onlyProxy {\r\n        require(LnProxyBase(msg.sender) == proxy || LnProxyBase(msg.sender) == integrationProxy, \"Only the proxy can call\");\r\n        _;\r\n    }\r\n\r\n    modifier optionalProxy {\r\n        if (LnProxyBase(msg.sender) != proxy && LnProxyBase(msg.sender) != integrationProxy && messageSender != msg.sender) {\r\n            messageSender = msg.sender;\r\n        }\r\n        _;\r\n    }\r\n\r\n    modifier optionalProxy_onlyAdmin {\r\n        if (LnProxyBase(msg.sender) != proxy && LnProxyBase(msg.sender) != integrationProxy && messageSender != msg.sender) {\r\n            messageSender = msg.sender;\r\n        }\r\n        require(messageSender == admin, \"only for admin\");\r\n        _;\r\n    }\r\n\r\n    event ProxyUpdated(address proxyAddress);\r\n}\r\n\r\ncontract LnProxyERC20 is LnProxyBase, IERC20 {\r\n    constructor(address _admin) public LnProxyBase(_admin) {}\r\n\r\n    function name() public view override returns (string memory) {\r\n        \r\n        return IERC20(address(target)).name();\r\n    }\r\n\r\n    function symbol() public view override returns (string memory) {\r\n        \r\n        return IERC20(address(target)).symbol();\r\n    }\r\n\r\n    function decimals() public view override returns (uint8) {\r\n        \r\n        return IERC20(address(target)).decimals();\r\n    }\r\n\r\n    function totalSupply() public view override returns (uint256) {\r\n        \r\n        return IERC20(address(target)).totalSupply();\r\n    }\r\n\r\n    function balanceOf(address account) public view override returns (uint256) {\r\n        \r\n        return IERC20(address(target)).balanceOf(account);\r\n    }\r\n\r\n    function allowance(address owner, address spender) public view override returns (uint256) {\r\n        \r\n        return IERC20(address(target)).allowance(owner, spender);\r\n    }\r\n\r\n    function transfer(address to, uint256 value) public override returns (bool) {\r\n        \r\n        target.setMessageSender(msg.sender);\r\n\r\n        IERC20(address(target)).transfer(to, value);\r\n\r\n        return true;\r\n    }\r\n\r\n    function approve(address spender, uint256 value) public override returns (bool) {\r\n        \r\n        target.setMessageSender(msg.sender);\r\n\r\n        IERC20(address(target)).approve(spender, value);\r\n\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) public override returns (bool) {\r\n        \r\n        target.setMessageSender(msg.sender);\r\n\r\n        IERC20(address(target)).transferFrom(from, to, value);\r\n\r\n        return true;\r\n    }\r\n}"
    }
  }
}