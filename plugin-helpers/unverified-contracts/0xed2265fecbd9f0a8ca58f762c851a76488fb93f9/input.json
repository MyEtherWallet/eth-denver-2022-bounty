{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "MintableSale.sol": {
      "content": "// File: contracts/interfaces/IMintableERC721.sol\r\n\r\n\r\npragma solidity ^0.8.10;\r\n\r\ninterface IMintableERC721 {\r\n\t/**\r\n\t * @notice Checks if specified token exists\r\n\t *\r\n\t * @dev Returns whether the specified token ID has an ownership\r\n\t *      information associated with it\r\n\t *\r\n\t * @param _tokenId ID of the token to query existence for\r\n\t * @return whether the token exists (true - exists, false - doesn't exist)\r\n\t */\r\n\tfunction exists(uint256 _tokenId) external view returns(bool);\r\n\r\n\t/**\r\n\t * @dev Creates new token with token ID specified\r\n\t *      and assigns an ownership `_to` for this token\r\n\t *\r\n\t * @dev Unsafe: doesn't execute `onERC721Received` on the receiver.\r\n\t *      Prefer the use of `saveMint` instead of `mint`.\r\n\t *\r\n\t * @dev Should have a restricted access handled by the implementation\r\n\t *\r\n\t * @param _to an address to mint token to\r\n\t * @param _tokenId ID of the token to mint\r\n\t */\r\n\tfunction mint(address _to, uint256 _tokenId) external;\r\n\r\n\t/**\r\n\t * @dev Creates new tokens starting with token ID specified\r\n\t *      and assigns an ownership `_to` for these tokens\r\n\t *\r\n\t * @dev Token IDs to be minted: [_tokenId, _tokenId + n)\r\n\t *\r\n\t * @dev n must be greater or equal 2: `n > 1`\r\n\t *\r\n\t * @dev Unsafe: doesn't execute `onERC721Received` on the receiver.\r\n\t *      Prefer the use of `saveMintBatch` instead of `mintBatch`.\r\n\t *\r\n\t * @dev Should have a restricted access handled by the implementation\r\n\t *\r\n\t * @param _to an address to mint tokens to\r\n\t * @param _tokenId ID of the first token to mint\r\n\t * @param n how many tokens to mint, sequentially increasing the _tokenId\r\n\t */\r\n\tfunction mintBatch(address _to, uint256 _tokenId, uint256 n) external;\r\n\r\n\t/**\r\n\t * @dev Creates new token with token ID specified\r\n\t *      and assigns an ownership `_to` for this token\r\n\t *\r\n\t * @dev Checks if `_to` is a smart contract (code size > 0). If so, it calls\r\n\t *      `onERC721Received` on `_to` and throws if the return value is not\r\n\t *      `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`.\r\n\t *\r\n\t * @dev Should have a restricted access handled by the implementation\r\n\t *\r\n\t * @param _to an address to mint token to\r\n\t * @param _tokenId ID of the token to mint\r\n\t */\r\n\tfunction safeMint(address _to, uint256 _tokenId) external;\r\n\r\n\t/**\r\n\t * @dev Creates new token with token ID specified\r\n\t *      and assigns an ownership `_to` for this token\r\n\t *\r\n\t * @dev Checks if `_to` is a smart contract (code size > 0). If so, it calls\r\n\t *      `onERC721Received` on `_to` and throws if the return value is not\r\n\t *      `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`.\r\n\t *\r\n\t * @dev Should have a restricted access handled by the implementation\r\n\t *\r\n\t * @param _to an address to mint token to\r\n\t * @param _tokenId ID of the token to mint\r\n\t * @param _data additional data with no specified format, sent in call to `_to`\r\n\t */\r\n\tfunction safeMint(address _to, uint256 _tokenId, bytes memory _data) external;\r\n\r\n\t/**\r\n\t * @dev Creates new tokens starting with token ID specified\r\n\t *      and assigns an ownership `_to` for these tokens\r\n\t *\r\n\t * @dev Token IDs to be minted: [_tokenId, _tokenId + n)\r\n\t *\r\n\t * @dev n must be greater or equal 2: `n > 1`\r\n\t *\r\n\t * @dev Checks if `_to` is a smart contract (code size > 0). If so, it calls\r\n\t *      `onERC721Received` on `_to` and throws if the return value is not\r\n\t *      `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`.\r\n\t *\r\n\t * @dev Should have a restricted access handled by the implementation\r\n\t *\r\n\t * @param _to an address to mint token to\r\n\t * @param _tokenId ID of the token to mint\r\n\t * @param n how many tokens to mint, sequentially increasing the _tokenId\r\n\t */\r\n\tfunction safeMintBatch(address _to, uint256 _tokenId, uint256 n) external;\r\n\r\n\t/**\r\n\t * @dev Creates new tokens starting with token ID specified\r\n\t *      and assigns an ownership `_to` for these tokens\r\n\t *\r\n\t * @dev Token IDs to be minted: [_tokenId, _tokenId + n)\r\n\t *\r\n\t * @dev n must be greater or equal 2: `n > 1`\r\n\t *\r\n\t * @dev Checks if `_to` is a smart contract (code size > 0). If so, it calls\r\n\t *      `onERC721Received` on `_to` and throws if the return value is not\r\n\t *      `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`.\r\n\t *\r\n\t * @dev Should have a restricted access handled by the implementation\r\n\t *\r\n\t * @param _to an address to mint token to\r\n\t * @param _tokenId ID of the token to mint\r\n\t * @param n how many tokens to mint, sequentially increasing the _tokenId\r\n\t * @param _data additional data with no specified format, sent in call to `_to`\r\n\t */\r\n\tfunction safeMintBatch(address _to, uint256 _tokenId, uint256 n, bytes memory _data) external;\r\n}\r\n// File: @openzeppelin/contracts/security/ReentrancyGuard.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Contract module that helps prevent reentrant calls to a function.\r\n *\r\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\r\n * available, which can be applied to functions to make sure there are no nested\r\n * (reentrant) calls to them.\r\n *\r\n * Note that because there is a single `nonReentrant` guard, functions marked as\r\n * `nonReentrant` may not call one another. This can be worked around by making\r\n * those functions `private`, and then adding `external` `nonReentrant` entry\r\n * points to them.\r\n *\r\n * TIP: If you would like to learn more about reentrancy and alternative ways\r\n * to protect against it, check out our blog post\r\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\r\n */\r\nabstract contract ReentrancyGuard {\r\n    // Booleans are more expensive than uint256 or any type that takes up a full\r\n    // word because each write operation emits an extra SLOAD to first read the\r\n    // slot's contents, replace the bits taken up by the boolean, and then write\r\n    // back. This is the compiler's defense against contract upgrades and\r\n    // pointer aliasing, and it cannot be disabled.\r\n\r\n    // The values being non-zero value makes deployment a bit more expensive,\r\n    // but in exchange the refund on every call to nonReentrant will be lower in\r\n    // amount. Since refunds are capped to a percentage of the total\r\n    // transaction's gas, it is best to keep them low in cases like this one, to\r\n    // increase the likelihood of the full refund coming into effect.\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    constructor() {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and making it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        // On the first call to nonReentrant, _notEntered will be true\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n\r\n        // Any calls to nonReentrant after this point will fail\r\n        _status = _ENTERED;\r\n\r\n        _;\r\n\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        _status = _NOT_ENTERED;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/Address.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/Address.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies on extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        uint256 size;\r\n        assembly {\r\n            size := extcodesize(account)\r\n        }\r\n        return size > 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        (bool success, ) = recipient.call{value: amount}(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a Solidity function call using a low level `call`. A\r\n     * plain `call` is an unsafe replacement for a function call: use this\r\n     * function instead.\r\n     *\r\n     * If `target` reverts with a revert reason, it is bubbled up by this\r\n     * function (like regular Solidity function calls).\r\n     *\r\n     * Returns the raw returned data. To convert to the expected return value,\r\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `target` must be a contract.\r\n     * - calling `target` with `data` must not revert.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n     * `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but also transferring `value` wei to `target`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the calling contract must have an ETH balance of at least `value`.\r\n     * - the called Solidity function must be `payable`.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\r\n        return verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal view returns (bytes memory) {\r\n        require(isContract(target), \"Address: static call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(isContract(target), \"Address: delegate call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.delegatecall(data);\r\n        return verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\r\n     * revert reason using the provided one.\r\n     *\r\n     * _Available since v4.3._\r\n     */\r\n    function verifyCallResult(\r\n        bool success,\r\n        bytes memory returndata,\r\n        string memory errorMessage\r\n    ) internal pure returns (bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            // Look for revert reason and bubble it up if present\r\n            if (returndata.length > 0) {\r\n                // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC20/IERC20.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/IERC20.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\r\n * contract returns false). Tokens that return no value (and instead revert or\r\n * throw on failure) are also supported, non-reverting calls are assumed to be\r\n * successful.\r\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n    using Address for address;\r\n\r\n    function safeTransfer(\r\n        IERC20 token,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        IERC20 token,\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    /**\r\n     * @dev Deprecated. This function has issues similar to the ones found in\r\n     * {IERC20-approve}, and its usage is discouraged.\r\n     *\r\n     * Whenever possible, use {safeIncreaseAllowance} and\r\n     * {safeDecreaseAllowance} instead.\r\n     */\r\n    function safeApprove(\r\n        IERC20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n        require(\r\n            (value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(\r\n        IERC20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(\r\n        IERC20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        unchecked {\r\n            uint256 oldAllowance = token.allowance(address(this), spender);\r\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\r\n            uint256 newAllowance = oldAllowance - value;\r\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\r\n        // the target address contains contract code and also asserts for success in the low-level call.\r\n\r\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\r\n        if (returndata.length > 0) {\r\n            // Return data is optional\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/introspection/IERC165.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC165 standard, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\r\n *\r\n * Implementers can declare support of contract interfaces, which can then be\r\n * queried by others ({ERC165Checker}).\r\n *\r\n * For an implementation, see {ERC165}.\r\n */\r\ninterface IERC165 {\r\n    /**\r\n     * @dev Returns true if this contract implements the interface defined by\r\n     * `interfaceId`. See the corresponding\r\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\r\n     * to learn more about how these ids are created.\r\n     *\r\n     * This function call must use less than 30 000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC721/IERC721.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n/**\r\n * @dev Required interface of an ERC721 compliant contract.\r\n */\r\ninterface IERC721 is IERC165 {\r\n    /**\r\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n\r\n    /**\r\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\r\n     */\r\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n\r\n    /**\r\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\r\n     */\r\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n\r\n    /**\r\n     * @dev Returns the number of tokens in ``owner``'s account.\r\n     */\r\n    function balanceOf(address owner) external view returns (uint256 balance);\r\n\r\n    /**\r\n     * @dev Returns the owner of the `tokenId` token.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     */\r\n    function ownerOf(uint256 tokenId) external view returns (address owner);\r\n\r\n    /**\r\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\r\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must exist and be owned by `from`.\r\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\r\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Transfers `tokenId` token from `from` to `to`.\r\n     *\r\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must be owned by `from`.\r\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\r\n     * The approval is cleared when the token is transferred.\r\n     *\r\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The caller must own the token or be an approved operator.\r\n     * - `tokenId` must exist.\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address to, uint256 tokenId) external;\r\n\r\n    /**\r\n     * @dev Returns the account approved for `tokenId` token.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     */\r\n    function getApproved(uint256 tokenId) external view returns (address operator);\r\n\r\n    /**\r\n     * @dev Approve or remove `operator` as an operator for the caller.\r\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The `operator` cannot be the caller.\r\n     *\r\n     * Emits an {ApprovalForAll} event.\r\n     */\r\n    function setApprovalForAll(address operator, bool _approved) external;\r\n\r\n    /**\r\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\r\n     *\r\n     * See {setApprovalForAll}\r\n     */\r\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\r\n\r\n    /**\r\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must exist and be owned by `from`.\r\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\r\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes calldata data\r\n    ) external;\r\n}\r\n\r\n// File: @openzeppelin/contracts/interfaces/IERC721.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC721.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n// File: @openzeppelin/contracts/interfaces/IERC165.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC165.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n// File: @openzeppelin/contracts/utils/cryptography/MerkleProof.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/cryptography/MerkleProof.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev These functions deal with verification of Merkle Trees proofs.\r\n *\r\n * The proofs can be generated using the JavaScript library\r\n * https://github.com/miguelmota/merkletreejs[merkletreejs].\r\n * Note: the hashing algorithm should be keccak256 and pair sorting should be enabled.\r\n *\r\n * See `test/utils/cryptography/MerkleProof.test.js` for some examples.\r\n */\r\nlibrary MerkleProof {\r\n    /**\r\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\r\n     * defined by `root`. For this, a `proof` must be provided, containing\r\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\r\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\r\n     */\r\n    function verify(\r\n        bytes32[] memory proof,\r\n        bytes32 root,\r\n        bytes32 leaf\r\n    ) internal pure returns (bool) {\r\n        return processProof(proof, leaf) == root;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the rebuilt hash obtained by traversing a Merklee tree up\r\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\r\n     * hash matches the root of the tree. When processing the proof, the pairs\r\n     * of leafs & pre-images are assumed to be sorted.\r\n     *\r\n     * _Available since v4.4._\r\n     */\r\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\r\n        bytes32 computedHash = leaf;\r\n        for (uint256 i = 0; i < proof.length; i++) {\r\n            bytes32 proofElement = proof[i];\r\n            if (computedHash <= proofElement) {\r\n                // Hash(current computed hash + current element of the proof)\r\n                computedHash = keccak256(abi.encodePacked(computedHash, proofElement));\r\n            } else {\r\n                // Hash(current element of the proof + current computed hash)\r\n                computedHash = keccak256(abi.encodePacked(proofElement, computedHash));\r\n            }\r\n        }\r\n        return computedHash;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/Context.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/finance/PaymentSplitter.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (finance/PaymentSplitter.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n\r\n\r\n/**\r\n * @title PaymentSplitter\r\n * @dev This contract allows to split Ether payments among a group of accounts. The sender does not need to be aware\r\n * that the Ether will be split in this way, since it is handled transparently by the contract.\r\n *\r\n * The split can be in equal parts or in any other arbitrary proportion. The way this is specified is by assigning each\r\n * account to a number of shares. Of all the Ether that this contract receives, each account will then be able to claim\r\n * an amount proportional to the percentage of total shares they were assigned.\r\n *\r\n * `PaymentSplitter` follows a _pull payment_ model. This means that payments are not automatically forwarded to the\r\n * accounts but kept in this contract, and the actual transfer is triggered as a separate step by calling the {release}\r\n * function.\r\n *\r\n * NOTE: This contract assumes that ERC20 tokens will behave similarly to native tokens (Ether). Rebasing tokens, and\r\n * tokens that apply fees during transfers, are likely to not be supported as expected. If in doubt, we encourage you\r\n * to run tests before sending real value to this contract.\r\n */\r\ncontract PaymentSplitter is Context {\r\n    event PayeeAdded(address account, uint256 shares);\r\n    event PaymentReleased(address to, uint256 amount);\r\n    event ERC20PaymentReleased(IERC20 indexed token, address to, uint256 amount);\r\n    event PaymentReceived(address from, uint256 amount);\r\n\r\n    uint256 private _totalShares;\r\n    uint256 private _totalReleased;\r\n\r\n    mapping(address => uint256) private _shares;\r\n    mapping(address => uint256) private _released;\r\n    address[] private _payees;\r\n\r\n    mapping(IERC20 => uint256) private _erc20TotalReleased;\r\n    mapping(IERC20 => mapping(address => uint256)) private _erc20Released;\r\n\r\n    /**\r\n     * @dev Creates an instance of `PaymentSplitter` where each account in `payees` is assigned the number of shares at\r\n     * the matching position in the `shares` array.\r\n     *\r\n     * All addresses in `payees` must be non-zero. Both arrays must have the same non-zero length, and there must be no\r\n     * duplicates in `payees`.\r\n     */\r\n    constructor(address[] memory payees, uint256[] memory shares_) payable {\r\n        require(payees.length == shares_.length, \"PaymentSplitter: payees and shares length mismatch\");\r\n        require(payees.length > 0, \"PaymentSplitter: no payees\");\r\n\r\n        for (uint256 i = 0; i < payees.length; i++) {\r\n            _addPayee(payees[i], shares_[i]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev The Ether received will be logged with {PaymentReceived} events. Note that these events are not fully\r\n     * reliable: it's possible for a contract to receive Ether without triggering this function. This only affects the\r\n     * reliability of the events, and not the actual splitting of Ether.\r\n     *\r\n     * To learn more about this see the Solidity documentation for\r\n     * https://solidity.readthedocs.io/en/latest/contracts.html#fallback-function[fallback\r\n     * functions].\r\n     */\r\n    receive() external payable virtual {\r\n        emit PaymentReceived(_msgSender(), msg.value);\r\n    }\r\n\r\n    /**\r\n     * @dev Getter for the total shares held by payees.\r\n     */\r\n    function totalShares() public view returns (uint256) {\r\n        return _totalShares;\r\n    }\r\n\r\n    /**\r\n     * @dev Getter for the total amount of Ether already released.\r\n     */\r\n    function totalReleased() public view returns (uint256) {\r\n        return _totalReleased;\r\n    }\r\n\r\n    /**\r\n     * @dev Getter for the total amount of `token` already released. `token` should be the address of an IERC20\r\n     * contract.\r\n     */\r\n    function totalReleased(IERC20 token) public view returns (uint256) {\r\n        return _erc20TotalReleased[token];\r\n    }\r\n\r\n    /**\r\n     * @dev Getter for the amount of shares held by an account.\r\n     */\r\n    function shares(address account) public view returns (uint256) {\r\n        return _shares[account];\r\n    }\r\n\r\n    /**\r\n     * @dev Getter for the amount of Ether already released to a payee.\r\n     */\r\n    function released(address account) public view returns (uint256) {\r\n        return _released[account];\r\n    }\r\n\r\n    /**\r\n     * @dev Getter for the amount of `token` tokens already released to a payee. `token` should be the address of an\r\n     * IERC20 contract.\r\n     */\r\n    function released(IERC20 token, address account) public view returns (uint256) {\r\n        return _erc20Released[token][account];\r\n    }\r\n\r\n    /**\r\n     * @dev Getter for the address of the payee number `index`.\r\n     */\r\n    function payee(uint256 index) public view returns (address) {\r\n        return _payees[index];\r\n    }\r\n\r\n    /**\r\n     * @dev Triggers a transfer to `account` of the amount of Ether they are owed, according to their percentage of the\r\n     * total shares and their previous withdrawals.\r\n     */\r\n    function release(address payable account) public virtual {\r\n        require(_shares[account] > 0, \"PaymentSplitter: account has no shares\");\r\n\r\n        uint256 totalReceived = address(this).balance + totalReleased();\r\n        uint256 payment = _pendingPayment(account, totalReceived, released(account));\r\n\r\n        require(payment != 0, \"PaymentSplitter: account is not due payment\");\r\n\r\n        _released[account] += payment;\r\n        _totalReleased += payment;\r\n\r\n        Address.sendValue(account, payment);\r\n        emit PaymentReleased(account, payment);\r\n    }\r\n\r\n    /**\r\n     * @dev Triggers a transfer to `account` of the amount of `token` tokens they are owed, according to their\r\n     * percentage of the total shares and their previous withdrawals. `token` must be the address of an IERC20\r\n     * contract.\r\n     */\r\n    function release(IERC20 token, address account) public virtual {\r\n        require(_shares[account] > 0, \"PaymentSplitter: account has no shares\");\r\n\r\n        uint256 totalReceived = token.balanceOf(address(this)) + totalReleased(token);\r\n        uint256 payment = _pendingPayment(account, totalReceived, released(token, account));\r\n\r\n        require(payment != 0, \"PaymentSplitter: account is not due payment\");\r\n\r\n        _erc20Released[token][account] += payment;\r\n        _erc20TotalReleased[token] += payment;\r\n\r\n        SafeERC20.safeTransfer(token, account, payment);\r\n        emit ERC20PaymentReleased(token, account, payment);\r\n    }\r\n\r\n    /**\r\n     * @dev internal logic for computing the pending payment of an `account` given the token historical balances and\r\n     * already released amounts.\r\n     */\r\n    function _pendingPayment(\r\n        address account,\r\n        uint256 totalReceived,\r\n        uint256 alreadyReleased\r\n    ) private view returns (uint256) {\r\n        return (totalReceived * _shares[account]) / _totalShares - alreadyReleased;\r\n    }\r\n\r\n    /**\r\n     * @dev Add a new payee to the contract.\r\n     * @param account The address of the payee to add.\r\n     * @param shares_ The number of shares owned by the payee.\r\n     */\r\n    function _addPayee(address account, uint256 shares_) private {\r\n        require(account != address(0), \"PaymentSplitter: account is the zero address\");\r\n        require(shares_ > 0, \"PaymentSplitter: shares are 0\");\r\n        require(_shares[account] == 0, \"PaymentSplitter: account already has shares\");\r\n\r\n        _payees.push(account);\r\n        _shares[account] = shares_;\r\n        _totalShares = _totalShares + shares_;\r\n        emit PayeeAdded(account, shares_);\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/access/Ownable.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Internal function without access restriction.\r\n     */\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\n// File: contracts/MintableSale.sol\r\n\r\n\r\npragma solidity ^0.8.10;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title Mintable Sale\r\n *\r\n * @notice Mintable Sale sales fixed amount of NFTs (tokens) for a fixed price in a fixed period of time;\r\n *      it can be used in a 10k sale campaign and the smart contract is generic and\r\n *      can sell any type of mintable NFT (see MintableERC721 interface)\r\n *\r\n * @dev Fixed parameters should not be changed mid sale because the minted per walet gets reset each time\r\n *\r\n * @dev When buying a token from this smart contract, next token is minted to the recipient\r\n *\r\n * @dev Supports functionality to limit amount of tokens that can be minted to each address\r\n *\r\n * @dev Deployment and setup:\r\n *      1. Deploy smart contract, specify smart contract address during the deployment:\r\n *         - Mintable ER721 deployed instance address\r\n *      2. Execute `initialize` function and set up the sale parameters;\r\n *         sale is not active until it's initialized\r\n *\r\n */\r\ncontract MintableSale is Ownable, PaymentSplitter, ReentrancyGuard {\r\n  // Use Zeppelin MerkleProof Library to verify Merkle proofs\r\n  using MerkleProof for bytes32[];\r\n\r\n  // ----- SLOT.1 (192/256)\r\n  /**\r\n   * @dev Next token ID to mint;\r\n   *      initially this is the first \"free\" ID which can be minted;\r\n   *      at any point in time this should point to a free, mintable ID\r\n   *      for the token\r\n   *\r\n   * @dev `nextId` cannot be zero, we do not ever mint NFTs with zero IDs\r\n   */\r\n  uint32 public nextId = 1;\r\n\r\n  /**\r\n   * @dev Last token ID to mint;\r\n   *      once `nextId` exceeds `finalId` the sale pauses\r\n   */\r\n  uint32 public finalId;\r\n\r\n  /**\r\n   * @notice Once set, limits the amount of tokens one can buy in a single transaction;\r\n   *       When unset (zero) the amount of tokens is limited only by block size and\r\n   *       amount of tokens left for sale\r\n   */\r\n  uint32 public batchLimit;\r\n\r\n  /**\r\n   * @notice Once set, limits the amount of tokens one address can buy for the duration of the sale;\r\n   *       When unset (zero) the amount of tokens is limited only by the amount of tokens left for sale\r\n   */\r\n  uint32 public mintLimit;\r\n\r\n  /**\r\n   * @notice Counter of the tokens sold (minted) by this sale smart contract\r\n   */\r\n  uint32 public soldCounter;\r\n\r\n  /**\r\n   * @notice Merkle tree root to validate (address, cost, startDate, endDate)\r\n   *         tuples\r\n   */\r\n  bytes32 public root;\r\n\r\n  // ----- NON-SLOTTED\r\n  /**\r\n   * @dev Mintable ERC721 contract address to mint\r\n   */\r\n  address public immutable tokenContract;\r\n\r\n  // ----- NON-SLOTTED\r\n  /**\r\n   * @dev Number of mints performed by address\r\n   */\r\n  mapping(uint32 => mapping(address => uint32)) public mints;\r\n\r\n  // ----- NON-SLOTTED\r\n  /**\r\n   * @dev Is this a public sale or a private one (Merkle root verify or not)\r\n   */\r\n  bool public isPublicSale = false;\r\n\r\n  // ----- NON-SLOTTED\r\n  /**\r\n   * @dev Sale number for contract - starts from 0 and increments to 1 for each new sale.\r\n   * Used for resetting mints per wallet each sale.\r\n   */\r\n  uint32 public saleNumber = 0;\r\n  /**\r\n   * @dev Fired in initialize()\r\n   *\r\n   * @param _by an address which executed the initialization\r\n   * @param _nextId next ID of the token to mint\r\n   * @param _finalId final ID of the token to mint\r\n   * @param _batchLimit how many tokens is allowed to buy in a single transaction\r\n   * @param _root merkle tree root\r\n   */\r\n  event Initialized(\r\n    address indexed _by,\r\n    uint32 _nextId,\r\n    uint32 _finalId,\r\n    uint32 _batchLimit,\r\n    uint32 _limit,\r\n    bytes32 _root,\r\n    bool _isPublicSale\r\n  );\r\n\r\n  /**\r\n   * @dev Fired in buy(), buyTo(), buySingle(), and buySingleTo()\r\n   *\r\n   * @param _by an address which executed and payed the transaction, probably a buyer\r\n   * @param _to an address which received token(s) minted\r\n   * @param _amount number of tokens minted\r\n   * @param _value ETH amount charged\r\n   */\r\n  event Bought(\r\n    address indexed _by,\r\n    address indexed _to,\r\n    uint256 _amount,\r\n    uint256 _value\r\n  );\r\n\r\n  /**\r\n   * @dev Creates/deploys MintableSale and binds it to Mintable ERC721\r\n   *      smart contract on construction\r\n   *\r\n   * @param _tokenContract deployed Mintable ERC721 smart contract; sale will mint ERC721\r\n   *      tokens of that type to the recipient\r\n   */\r\n  constructor(\r\n    address _tokenContract,\r\n    address[] memory addressList,\r\n    uint256[] memory shareList\r\n  ) PaymentSplitter(addressList, shareList) {\r\n    // verify the input is set\r\n    require(_tokenContract != address(0), \"token contract is not set\");\r\n\r\n    // verify input is valid smart contract of the expected interfaces\r\n    require(\r\n      IERC165(_tokenContract).supportsInterface(\r\n        type(IMintableERC721).interfaceId\r\n      ),\r\n      \"unexpected token contract type\"\r\n    );\r\n\r\n    // assign the addresses\r\n    tokenContract = _tokenContract;\r\n  }\r\n\r\n  /**\r\n   * @notice Number of tokens left on sale\r\n   *\r\n   * @dev Doesn't take into account if sale is active or not\r\n   *\r\n   * @return number of tokens left on sale\r\n   */\r\n  function itemsOnSale() public view returns (uint32) {\r\n    // calculate items left on sale, taking into account that\r\n    // finalId is on sale (inclusive bound)\r\n    return finalId >= nextId ? finalId + 1 - nextId : 0;\r\n  }\r\n\r\n  /**\r\n   * @notice Number of tokens available on sale\r\n   *\r\n   * @dev Takes into account if sale is active or not, doesn't throw,\r\n   *      returns zero if sale is inactive\r\n   *\r\n   * @return number of tokens available on sale\r\n   */\r\n  function itemsAvailable() public view returns (uint32) {\r\n    // delegate to itemsOnSale() if sale is active, return zero otherwise\r\n    return isActive() ? itemsOnSale() : 0;\r\n  }\r\n\r\n  /**\r\n   * @notice Active sale is an operational sale capable of minting and selling tokens\r\n   *\r\n   * @dev The sale is active when all the requirements below are met:\r\n   *      1. `finalId` is not reached (`nextId <= finalId`)\r\n   *\r\n   * @dev Function is marked as virtual to be overridden in the helper test smart contract (mock)\r\n   *      in order to test how it affects the sale process\r\n   *\r\n   * @return true if sale is active (operational) and can sell tokens, false otherwise\r\n   */\r\n  function isActive() public view virtual returns (bool) {\r\n    // evaluate sale state based on the internal state variables and return\r\n    return nextId <= finalId;\r\n  }\r\n\r\n  /**\r\n   * @dev Restricted access function to set up sale parameters, all at once,\r\n   *      or any subset of them\r\n   *\r\n   * @dev To skip parameter initialization, set it to `-1`,\r\n   *      that is a maximum value for unsigned integer of the corresponding type;\r\n   *      `_aliSource` and `_aliValue` must both be either set or skipped\r\n   *\r\n   * @dev Example: following initialization will update only _itemPrice and _batchLimit,\r\n   *      leaving the rest of the fields unchanged\r\n   *      initialize(\r\n   *          0xFFFFFFFF,\r\n   *          0xFFFFFFFF,\r\n   *          10,\r\n   *          0xFFFFFFFF\r\n   *      )\r\n   *\r\n   * @dev Requires next ID to be greater than zero (strict): `_nextId > 0`\r\n   *\r\n   * @dev Requires transaction sender to have `ROLE_SALE_MANAGER` role\r\n   *\r\n   * @param _nextId next ID of the token to mint, will be increased\r\n   *      in smart contract storage after every successful buy\r\n   * @param _finalId final ID of the token to mint; sale is capable of producing\r\n   *      `_finalId - _nextId + 1` tokens\r\n   *      when current time is within _saleStart (inclusive) and _saleEnd (exclusive)\r\n   * @param _batchLimit how many tokens is allowed to buy in a single transaction,\r\n   *      set to zero to disable the limit\r\n   * @param _mintLimit how many tokens is allowed to buy for the duration of the sale,\r\n   *      set to zero to disable the limit\r\n   * @param _root merkle tree root used to verify whether an address can mint\r\n   */\r\n  function initialize(\r\n    uint32 _nextId, // <<<--- keep type in sync with the body type(uint32).max !!!\r\n    uint32 _finalId, // <<<--- keep type in sync with the body type(uint32).max !!!\r\n    uint32 _batchLimit, // <<<--- keep type in sync with the body type(uint32).max !!!\r\n    uint32 _mintLimit, // <<<--- keep type in sync with the body type(uint32).max !!!\r\n    bytes32 _root, // <<<--- keep type in sync with the 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF !!!\r\n    bool _isPublicSale\r\n  ) public onlyOwner {\r\n    // verify the inputs\r\n    require(_nextId > 0, \"zero nextId\");\r\n\r\n    // no need to verify extra parameters - \"incorrect\" values will deactivate the sale\r\n\r\n    // initialize contract state based on the values supplied\r\n    // take into account our convention that value `-1` means \"do not set\"\r\n    // 0xFFFFFFFFFFFFFFFF, 64 bits\r\n    // 0xFFFFFFFF, 32 bits\r\n    if (_nextId != type(uint32).max) {\r\n      nextId = _nextId;\r\n    }\r\n    // 0xFFFFFFFF, 32 bits\r\n    if (_finalId != type(uint32).max) {\r\n      finalId = _finalId;\r\n    }\r\n    // 0xFFFFFFFF, 32 bits\r\n    if (_batchLimit != type(uint32).max) {\r\n      batchLimit = _batchLimit;\r\n    }\r\n    // 0xFFFFFFFF, 32 bits\r\n    if (_mintLimit != type(uint32).max) {\r\n      mintLimit = _mintLimit;\r\n    }\r\n    // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF, 256 bits\r\n    if (\r\n      _root !=\r\n      0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\r\n    ) {\r\n      root = _root;\r\n    }\r\n\r\n    isPublicSale = _isPublicSale;\r\n\r\n    saleNumber++;\r\n\r\n    // emit an event - read values from the storage since not all of them might be set\r\n    emit Initialized(\r\n      msg.sender,\r\n      nextId,\r\n      finalId,\r\n      batchLimit,\r\n      mintLimit,\r\n      root,\r\n      isPublicSale\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @notice Buys several (at least two) tokens in a batch.\r\n   *      Accepts ETH as payment and mints a token\r\n   *\r\n   * @param _amount amount of tokens to create, two or more\r\n   */\r\n  function buy(\r\n    uint256 _price,\r\n    uint256 _start,\r\n    uint256 _end,\r\n    bytes32[] memory _proof,\r\n    uint32 _amount\r\n  ) public payable {\r\n    // delegate to `buyTo` with the transaction sender set to be a recipient\r\n    buyTo(msg.sender, _price, _start, _end, _proof, _amount);\r\n  }\r\n\r\n   /**\r\n   * @notice Buys several (at least two) tokens in a batch.\r\n   *      Accepts ETH as payment and mints a token\r\n   *\r\n   * @param _amount amount of tokens to create, two or more\r\n   */\r\n  function devBuy(\r\n    uint256 _price,\r\n    uint256 _start,\r\n    uint256 _end,\r\n    bytes32[] memory _proof,\r\n    uint32 _amount\r\n  ) public payable {\r\n    // delegate to `buyTo` with the transaction sender set to be a recipient\r\n    buyTo(msg.sender, _price, _start, _end, _proof, _amount);\r\n  }\r\n\r\n  /**\r\n   * @notice Buys several (at least two) tokens in a batch to an address specified.\r\n   *      Accepts ETH as payment and mints tokens\r\n   *\r\n   * @param _to address to mint tokens to\r\n   * @param _amount amount of tokens to create, two or more\r\n   */\r\n  function buyTo(\r\n    address _to,\r\n    uint256 _price,\r\n    uint256 _start,\r\n    uint256 _end,\r\n    bytes32[] memory _proof,\r\n    uint32 _amount\r\n  ) public payable nonReentrant {\r\n    if (isPublicSale) {\r\n      // disallow contracts from buying\r\n      require(msg.sender == tx.origin, \"Contract buys not allowed\");\r\n    }\r\n\r\n    // construct Merkle tree leaf from the inputs supplied\r\n    bytes32 leaf = buildLeaf(_price, _start, _end);\r\n\r\n    // verify proof\r\n    require(_proof.verify(root, leaf), \"invalid proof\");\r\n\r\n    // verify the inputs\r\n    require(_to != address(0), \"recipient not set\");\r\n    require(\r\n      _amount > 1 && (batchLimit == 0 || _amount <= batchLimit),\r\n      \"incorrect amount\"\r\n    );\r\n    require(block.timestamp >= _start, \"sale not yet started\");\r\n    require(block.timestamp <= _end, \"sale ended\");\r\n\r\n    // verify mint limit\r\n    if (mintLimit != 0) {\r\n      require(\r\n        mints[saleNumber][msg.sender] + _amount <= mintLimit,\r\n        \"mint limit reached\"\r\n      );\r\n    }\r\n\r\n    // verify there is enough items available to buy the amount\r\n    // verifies sale is in active state under the hood\r\n    require(\r\n      itemsAvailable() >= _amount,\r\n      \"inactive sale or not enough items available\"\r\n    );\r\n\r\n    // calculate the total price required and validate the transaction value\r\n    uint256 totalPrice = _price * _amount;\r\n    require(msg.value >= totalPrice, \"not enough funds\");\r\n\r\n    // increment sender mints\r\n    mints[saleNumber][msg.sender] += _amount;\r\n\r\n    // mint token to to the recipient\r\n    IMintableERC721(tokenContract).mintBatch(_to, nextId, _amount);\r\n\r\n    // increment `nextId`\r\n    nextId += _amount;\r\n    // increment `soldCounter`\r\n    soldCounter += _amount;\r\n\r\n    // if ETH amount supplied exceeds the price\r\n    if (msg.value > totalPrice) {\r\n      // send excess amount back to sender\r\n      payable(msg.sender).transfer(msg.value - totalPrice);\r\n    }\r\n\r\n    // emit en event\r\n    emit Bought(msg.sender, _to, _amount, totalPrice);\r\n  }\r\n\r\n   /**\r\n   * @notice Buys single token.\r\n   *      Accepts ETH as payment and mints a token\r\n   */\r\n  function devBuySingle(\r\n    uint256 _price,\r\n    uint256 _start,\r\n    uint256 _end,\r\n    bytes32[] memory _proof\r\n  ) public payable {\r\n    // delegate to `buySingleTo` with the transaction sender set to be a recipient\r\n    buySingleTo(msg.sender, _price, _start, _end, _proof);\r\n  }\r\n\r\n  /**\r\n   * @notice Buys single token.\r\n   *      Accepts ETH as payment and mints a token\r\n   */\r\n  function buySingle(\r\n    uint256 _price,\r\n    uint256 _start,\r\n    uint256 _end,\r\n    bytes32[] memory _proof\r\n  ) public payable {\r\n    // delegate to `buySingleTo` with the transaction sender set to be a recipient\r\n    buySingleTo(msg.sender, _price, _start, _end, _proof);\r\n  }\r\n\r\n  /**\r\n   * @notice Buys single token to an address specified.\r\n   *      Accepts ETH as payment and mints a token\r\n   *\r\n   * @param _to address to mint token to\r\n   */\r\n  function buySingleTo(\r\n    address _to,\r\n    uint256 _price,\r\n    uint256 _start,\r\n    uint256 _end,\r\n    bytes32[] memory _proof\r\n  ) public payable nonReentrant {\r\n    if (isPublicSale) {\r\n      // disallow contracts from buying\r\n      require(msg.sender == tx.origin, \"Contract buys not allowed\");\r\n    }\r\n    // construct Merkle tree leaf from the inputs supplied\r\n    bytes32 leaf = buildLeaf(_price, _start, _end);\r\n\r\n    // verify proof\r\n    require(_proof.verify(root, leaf), \"invalid proof\");\r\n\r\n    // verify the inputs and transaction value\r\n    require(_to != address(0), \"recipient not set\");\r\n    require(msg.value >= _price, \"not enough funds\");\r\n    require(block.timestamp >= _start, \"sale not yet started\");\r\n    require(block.timestamp <= _end, \"sale ended\");\r\n\r\n    // verify mint limit\r\n    if (mintLimit != 0) {\r\n      require(\r\n        mints[saleNumber][msg.sender] + 1 <= mintLimit,\r\n        \"mint limit reached\"\r\n      );\r\n    }\r\n\r\n    // verify sale is in active state\r\n    require(isActive(), \"inactive sale\");\r\n\r\n    // mint token to the recipient\r\n    IMintableERC721(tokenContract).mint(_to, nextId);\r\n\r\n    // increment `nextId`\r\n    nextId++;\r\n    // increment `soldCounter`\r\n    soldCounter++;\r\n    // increment sender mints\r\n    mints[saleNumber][msg.sender]++;\r\n\r\n    // if ETH amount supplied exceeds the price\r\n    if (msg.value > _price) {\r\n      // send excess amount back to sender\r\n      payable(msg.sender).transfer(msg.value - _price);\r\n    }\r\n\r\n    // emit en event\r\n    emit Bought(msg.sender, _to, 1, _price);\r\n  }\r\n\r\n  function buildLeaf(\r\n    uint256 _price,\r\n    uint256 _start,\r\n    uint256 _end\r\n  ) internal view returns (bytes32) {\r\n    // construct Merkle tree leaf from the inputs supplied\r\n    bytes32 leaf;\r\n    if (!isPublicSale) {\r\n      leaf = keccak256(abi.encodePacked(msg.sender, _price, _start, _end));\r\n    } else {\r\n      leaf = keccak256(abi.encodePacked(_price, _start, _end));\r\n    }\r\n    return leaf;\r\n  }\r\n}"
    }
  }
}