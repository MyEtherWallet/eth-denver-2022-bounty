{
  "language": "Solidity",
  "sources": {
    "contracts/PBAB/plottables/GenArt721Minter_Plottables.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"../../libs/SafeMath.sol\";\nimport \"../../libs/Strings.sol\";\n\nimport \"../../interfaces/IGenArt721CoreV2.sol\";\n\ninterface ERC20 {\n    function balanceOf(address _owner) external view returns (uint256 balance);\n\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _value\n    ) external returns (bool success);\n\n    function allowance(address _owner, address _spender)\n        external\n        view\n        returns (uint256 remaining);\n}\n\ninterface BonusContract {\n    function triggerBonus(address _to) external returns (bool);\n\n    function bonusIsActive() external view returns (bool);\n}\n\ncontract GenArt721Minter_Plottables {\n    using SafeMath for uint256;\n\n    IGenArt721CoreV2 public genArtCoreContract;\n\n    uint256 constant ONE_MILLION = 1_000_000;\n\n    address payable public ownerAddress;\n    uint256 public ownerPercentage;\n\n    mapping(uint256 => bool) public projectIdToBonus;\n    mapping(uint256 => address) public projectIdToBonusContractAddress;\n    mapping(uint256 => bool) public contractFilterProject;\n    mapping(address => mapping(uint256 => uint256)) public projectMintCounter;\n    mapping(uint256 => uint256) public projectMintLimit;\n    mapping(uint256 => bool) public projectMaxHasBeenInvoked;\n    mapping(uint256 => uint256) public projectMaxInvocations;\n\n    constructor(address _genArt721Address) public {\n        genArtCoreContract = IGenArt721CoreV2(_genArt721Address);\n    }\n\n    function getYourBalanceOfProjectERC20(uint256 _projectId)\n        public\n        view\n        returns (uint256)\n    {\n        uint256 balance = ERC20(\n            genArtCoreContract.projectIdToCurrencyAddress(_projectId)\n        ).balanceOf(msg.sender);\n        return balance;\n    }\n\n    function checkYourAllowanceOfProjectERC20(uint256 _projectId)\n        public\n        view\n        returns (uint256)\n    {\n        uint256 remaining = ERC20(\n            genArtCoreContract.projectIdToCurrencyAddress(_projectId)\n        ).allowance(msg.sender, address(this));\n        return remaining;\n    }\n\n    function setProjectMintLimit(uint256 _projectId, uint8 _limit) public {\n        require(\n            genArtCoreContract.isWhitelisted(msg.sender),\n            \"can only be set by admin\"\n        );\n        projectMintLimit[_projectId] = _limit;\n    }\n\n    function setProjectMaxInvocations(uint256 _projectId) public {\n        require(\n            genArtCoreContract.isWhitelisted(msg.sender),\n            \"can only be set by admin\"\n        );\n        uint256 maxInvocations;\n        uint256 invocations;\n        (, , invocations, maxInvocations, , , , , ) = genArtCoreContract\n            .projectTokenInfo(_projectId);\n        projectMaxInvocations[_projectId] = maxInvocations;\n        if (invocations < maxInvocations) {\n            projectMaxHasBeenInvoked[_projectId] = false;\n        }\n    }\n\n    function setOwnerAddress(address payable _ownerAddress) public {\n        require(\n            genArtCoreContract.isWhitelisted(msg.sender),\n            \"can only be set by admin\"\n        );\n        ownerAddress = _ownerAddress;\n    }\n\n    function setOwnerPercentage(uint256 _ownerPercentage) public {\n        require(\n            genArtCoreContract.isWhitelisted(msg.sender),\n            \"can only be set by admin\"\n        );\n        ownerPercentage = _ownerPercentage;\n    }\n\n    function toggleContractFilter(uint256 _projectId) public {\n        require(\n            genArtCoreContract.isWhitelisted(msg.sender),\n            \"can only be set by admin\"\n        );\n        contractFilterProject[_projectId] = !contractFilterProject[_projectId];\n    }\n\n    function artistToggleBonus(uint256 _projectId) public {\n        require(\n            msg.sender ==\n                genArtCoreContract.projectIdToArtistAddress(_projectId),\n            \"can only be set by artist\"\n        );\n        projectIdToBonus[_projectId] = !projectIdToBonus[_projectId];\n    }\n\n    function artistSetBonusContractAddress(\n        uint256 _projectId,\n        address _bonusContractAddress\n    ) public {\n        require(\n            msg.sender ==\n                genArtCoreContract.projectIdToArtistAddress(_projectId),\n            \"can only be set by artist\"\n        );\n        projectIdToBonusContractAddress[_projectId] = _bonusContractAddress;\n    }\n\n    function purchase(uint256 _projectId)\n        public\n        payable\n        returns (uint256 _tokenId)\n    {\n        return purchaseTo(msg.sender, _projectId);\n    }\n\n    // Remove `public`` and `payable`` to prevent public use\n    // of the `purchaseTo`` function.\n    function purchaseTo(address _to, uint256 _projectId)\n        public\n        payable\n        returns (uint256 _tokenId)\n    {\n        require(\n            !projectMaxHasBeenInvoked[_projectId],\n            \"Maximum number of invocations reached\"\n        );\n        if (\n            keccak256(\n                abi.encodePacked(\n                    genArtCoreContract.projectIdToCurrencySymbol(_projectId)\n                )\n            ) != keccak256(abi.encodePacked(\"ETH\"))\n        ) {\n            require(\n                msg.value == 0,\n                \"this project accepts a different currency and cannot accept ETH\"\n            );\n            require(\n                ERC20(genArtCoreContract.projectIdToCurrencyAddress(_projectId))\n                    .allowance(msg.sender, address(this)) >=\n                    genArtCoreContract.projectIdToPricePerTokenInWei(\n                        _projectId\n                    ),\n                \"Insufficient Funds Approved for TX\"\n            );\n            require(\n                ERC20(genArtCoreContract.projectIdToCurrencyAddress(_projectId))\n                    .balanceOf(msg.sender) >=\n                    genArtCoreContract.projectIdToPricePerTokenInWei(\n                        _projectId\n                    ),\n                \"Insufficient balance.\"\n            );\n            _splitFundsERC20(_projectId);\n        } else {\n            require(\n                msg.value >=\n                    genArtCoreContract.projectIdToPricePerTokenInWei(\n                        _projectId\n                    ),\n                \"Must send minimum value to mint!\"\n            );\n            _splitFundsETH(_projectId);\n        }\n\n        // if contract filter is active prevent calls from another contract\n        if (contractFilterProject[_projectId])\n            require(msg.sender == tx.origin, \"No Contract Buys\");\n\n        // limit mints per address by project\n        if (projectMintLimit[_projectId] > 0) {\n            require(\n                projectMintCounter[msg.sender][_projectId] <\n                    projectMintLimit[_projectId],\n                \"Reached minting limit\"\n            );\n            projectMintCounter[msg.sender][_projectId]++;\n        }\n\n        uint256 tokenId = genArtCoreContract.mint(_to, _projectId, msg.sender);\n\n        // What if this overflows, since default value of uint256 is 0?\n        // That is intended, so that by default the minter allows infinite\n        // transactions, allowing the `genArtCoreContract` to stop minting\n        // `uint256 tokenInvocation = tokenId % ONE_MILLION;`\n        if (tokenId % ONE_MILLION == projectMaxInvocations[_projectId] - 1) {\n            projectMaxHasBeenInvoked[_projectId] = true;\n        }\n\n        if (projectIdToBonus[_projectId]) {\n            require(\n                BonusContract(projectIdToBonusContractAddress[_projectId])\n                    .bonusIsActive(),\n                \"bonus must be active\"\n            );\n            BonusContract(projectIdToBonusContractAddress[_projectId])\n                .triggerBonus(msg.sender);\n        }\n\n        return tokenId;\n    }\n\n    function _splitFundsETH(uint256 _projectId) internal {\n        if (msg.value > 0) {\n            uint256 pricePerTokenInWei = genArtCoreContract\n                .projectIdToPricePerTokenInWei(_projectId);\n            uint256 refund = msg.value.sub(\n                genArtCoreContract.projectIdToPricePerTokenInWei(_projectId)\n            );\n            if (refund > 0) {\n                msg.sender.transfer(refund);\n            }\n            uint256 renderProviderAmount = pricePerTokenInWei.div(100).mul(\n                genArtCoreContract.renderProviderPercentage()\n            );\n            if (renderProviderAmount > 0) {\n                genArtCoreContract.renderProviderAddress().transfer(\n                    renderProviderAmount\n                );\n            }\n\n            uint256 remainingFunds = pricePerTokenInWei.sub(\n                renderProviderAmount\n            );\n\n            uint256 ownerFunds = remainingFunds.div(100).mul(ownerPercentage);\n            if (ownerFunds > 0) {\n                ownerAddress.transfer(ownerFunds);\n            }\n\n            uint256 projectFunds = pricePerTokenInWei\n                .sub(renderProviderAmount)\n                .sub(ownerFunds);\n            uint256 additionalPayeeAmount;\n            if (\n                genArtCoreContract.projectIdToAdditionalPayeePercentage(\n                    _projectId\n                ) > 0\n            ) {\n                additionalPayeeAmount = projectFunds.div(100).mul(\n                    genArtCoreContract.projectIdToAdditionalPayeePercentage(\n                        _projectId\n                    )\n                );\n                if (additionalPayeeAmount > 0) {\n                    genArtCoreContract\n                        .projectIdToAdditionalPayee(_projectId)\n                        .transfer(additionalPayeeAmount);\n                }\n            }\n            uint256 creatorFunds = projectFunds.sub(additionalPayeeAmount);\n            if (creatorFunds > 0) {\n                genArtCoreContract\n                    .projectIdToArtistAddress(_projectId)\n                    .transfer(creatorFunds);\n            }\n        }\n    }\n\n    function _splitFundsERC20(uint256 _projectId) internal {\n        uint256 pricePerTokenInWei = genArtCoreContract\n            .projectIdToPricePerTokenInWei(_projectId);\n        uint256 renderProviderAmount = pricePerTokenInWei.div(100).mul(\n            genArtCoreContract.renderProviderPercentage()\n        );\n        if (renderProviderAmount > 0) {\n            ERC20(genArtCoreContract.projectIdToCurrencyAddress(_projectId))\n                .transferFrom(\n                    msg.sender,\n                    genArtCoreContract.renderProviderAddress(),\n                    renderProviderAmount\n                );\n        }\n        uint256 remainingFunds = pricePerTokenInWei.sub(renderProviderAmount);\n\n        uint256 ownerFunds = remainingFunds.div(100).mul(ownerPercentage);\n        if (ownerFunds > 0) {\n            ERC20(genArtCoreContract.projectIdToCurrencyAddress(_projectId))\n                .transferFrom(msg.sender, ownerAddress, ownerFunds);\n        }\n\n        uint256 projectFunds = pricePerTokenInWei.sub(renderProviderAmount).sub(\n            ownerFunds\n        );\n        uint256 additionalPayeeAmount;\n        if (\n            genArtCoreContract.projectIdToAdditionalPayeePercentage(\n                _projectId\n            ) > 0\n        ) {\n            additionalPayeeAmount = projectFunds.div(100).mul(\n                genArtCoreContract.projectIdToAdditionalPayeePercentage(\n                    _projectId\n                )\n            );\n            if (additionalPayeeAmount > 0) {\n                ERC20(genArtCoreContract.projectIdToCurrencyAddress(_projectId))\n                    .transferFrom(\n                        msg.sender,\n                        genArtCoreContract.projectIdToAdditionalPayee(\n                            _projectId\n                        ),\n                        additionalPayeeAmount\n                    );\n            }\n        }\n        uint256 creatorFunds = projectFunds.sub(additionalPayeeAmount);\n        if (creatorFunds > 0) {\n            ERC20(genArtCoreContract.projectIdToCurrencyAddress(_projectId))\n                .transferFrom(\n                    msg.sender,\n                    genArtCoreContract.projectIdToArtistAddress(_projectId),\n                    creatorFunds\n                );\n        }\n    }\n}\n"
    },
    "contracts/libs/SafeMath.sol": {
      "content": "// File: openzeppelin-solidity/contracts/math/SafeMath.sol\n\npragma solidity ^0.5.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, \"SafeMath: division by zero\");\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n}\n"
    },
    "contracts/libs/Strings.sol": {
      "content": "// File: contracts/Strings.sol\n\npragma solidity ^0.5.0;\n\n//https://github.com/oraclize/ethereum-api/blob/master/oraclizeAPI_0.5.sol\nlibrary Strings {\n    function strConcat(string memory _a, string memory _b)\n        internal\n        pure\n        returns (string memory _concatenatedString)\n    {\n        return strConcat(_a, _b, \"\", \"\", \"\");\n    }\n\n    function strConcat(\n        string memory _a,\n        string memory _b,\n        string memory _c\n    ) internal pure returns (string memory _concatenatedString) {\n        return strConcat(_a, _b, _c, \"\", \"\");\n    }\n\n    function strConcat(\n        string memory _a,\n        string memory _b,\n        string memory _c,\n        string memory _d\n    ) internal pure returns (string memory _concatenatedString) {\n        return strConcat(_a, _b, _c, _d, \"\");\n    }\n\n    function strConcat(\n        string memory _a,\n        string memory _b,\n        string memory _c,\n        string memory _d,\n        string memory _e\n    ) internal pure returns (string memory _concatenatedString) {\n        bytes memory _ba = bytes(_a);\n        bytes memory _bb = bytes(_b);\n        bytes memory _bc = bytes(_c);\n        bytes memory _bd = bytes(_d);\n        bytes memory _be = bytes(_e);\n        string memory abcde = new string(\n            _ba.length + _bb.length + _bc.length + _bd.length + _be.length\n        );\n        bytes memory babcde = bytes(abcde);\n        uint256 k = 0;\n        uint256 i = 0;\n        for (i = 0; i < _ba.length; i++) {\n            babcde[k++] = _ba[i];\n        }\n        for (i = 0; i < _bb.length; i++) {\n            babcde[k++] = _bb[i];\n        }\n        for (i = 0; i < _bc.length; i++) {\n            babcde[k++] = _bc[i];\n        }\n        for (i = 0; i < _bd.length; i++) {\n            babcde[k++] = _bd[i];\n        }\n        for (i = 0; i < _be.length; i++) {\n            babcde[k++] = _be[i];\n        }\n        return string(babcde);\n    }\n\n    function uint2str(uint256 _i)\n        internal\n        pure\n        returns (string memory _uintAsString)\n    {\n        if (_i == 0) {\n            return \"0\";\n        }\n        uint256 j = _i;\n        uint256 len;\n        while (j != 0) {\n            len++;\n            j /= 10;\n        }\n        bytes memory bstr = new bytes(len);\n        uint256 k = len - 1;\n        while (_i != 0) {\n            bstr[k--] = bytes1(uint8(48 + (_i % 10)));\n            _i /= 10;\n        }\n        return string(bstr);\n    }\n}\n"
    },
    "contracts/interfaces/IGenArt721CoreV2.sol": {
      "content": "pragma solidity ^0.5.0;\n\ninterface IGenArt721CoreV2 {\n    function isWhitelisted(address sender) external view returns (bool);\n\n    function projectIdToCurrencySymbol(uint256 _projectId)\n        external\n        view\n        returns (string memory);\n\n    function projectIdToCurrencyAddress(uint256 _projectId)\n        external\n        view\n        returns (address);\n\n    function projectIdToArtistAddress(uint256 _projectId)\n        external\n        view\n        returns (address payable);\n\n    function projectIdToPricePerTokenInWei(uint256 _projectId)\n        external\n        view\n        returns (uint256);\n\n    function projectIdToAdditionalPayee(uint256 _projectId)\n        external\n        view\n        returns (address payable);\n\n    function projectIdToAdditionalPayeePercentage(uint256 _projectId)\n        external\n        view\n        returns (uint256);\n\n    function projectTokenInfo(uint256 _projectId)\n        external\n        view\n        returns (\n            address,\n            uint256,\n            uint256,\n            uint256,\n            bool,\n            address,\n            uint256,\n            string memory,\n            address\n        );\n\n    function renderProviderAddress() external view returns (address payable);\n\n    function renderProviderPercentage() external view returns (uint256);\n\n    function mint(\n        address _to,\n        uint256 _projectId,\n        address _by\n    ) external returns (uint256 tokenId);\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 100
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    },
    "libraries": {}
  }
}